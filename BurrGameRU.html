<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title data-translate="title">Burr Game V5.3 </title>
    <style>
        /* --- Base & Body --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1c1e; 
            overflow: hidden; 
            font-family: 'monospace', 'Courier New', monospace;
            touch-action: none; 
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background-color: #87CEEB; 
            border: 2px solid #000;
        }

        /* --- M3 STYLES & Menus --- */
        .game-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 28, 30, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            color: #e2e2e6;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }

        .menu-container {
            background-color: #2c2e30;
            padding: 30px;
            border-radius: 28px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            max-width: 90%;
            width: 400px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative; 
        }

        h1 { margin: 0; font-size: 32px; color: #ffb74d; }
        h2 { margin: 0; font-size: 24px; color: #e2e2e6; }
        h3 { margin: 10px 0 5px; font-size: 18px; color: #c4c7c5; }

        /* M3 Buttons */
        .menu-button {
            padding: 15px 24px;
            font-size: 18px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s, box-shadow 0.2s, background-color 0.2s;
            font-family: inherit;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-transform: uppercase;
        }

        .menu-button:active { transform: scale(0.96); }

        .btn-primary { background-color: #a8c7fa; color: #062e6f; }
        .btn-secondary { background-color: #d7c0ff; color: #3b0090; }
        .btn-danger { background-color: #ffb4ab; color: #690005; }
        .btn-warning { background-color: #ffdcbe; color: #5d4200; }
        .btn-info { background-color: #4fd8eb; color: #00363d; }
        
        /* Language Toggle */
        #langToggle {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 12px;
            background-color: #43474e;
            color: white;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s;
        }
        #langToggle:hover {
            background-color: #5d6166;
        }


        .grid-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        /* --- V5.2/V5.3: Updated Option Cards --- */
        .option-card {
            width: 80px; 
            height: 80px; 
            border-radius: 20px; 
            background-color: #43474e;
            border: 3px solid transparent;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
            position: relative;
        }

        .option-card.selected {
            border-color: #a8c7fa;
            background-color: #33363b;
            box-shadow: 0 0 0 4px rgba(168, 199, 250, 0.3);
        }

        .color-preview { width: 60px; height: 60px; border-radius: 16px; } 
        .shape-preview { 
            width: 60px; 
            height: 60px; 
            background-color: #fff; 
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
            color: black;
            font-size: 30px; 
            font-weight: 900;
        }
        
        /* V5.3: CSS Shape Styles */
        .shape-s_rect { border-radius: 10px; }
        .shape-s_circle { border-radius: 50%; }
        .shape-s_tri { 
            background: none !important; 
            width: 0; height: 0; 
            border-left: 30px solid transparent;
            border-right: 30px solid transparent;
            border-bottom: 52px solid #fff; 
            margin-top: -10px;
        }

        .shape-s_puffy { 
            background-color: #fff;
            border-radius: 30% / 40%; 
        }
        
        .shape-s_diamond {
            background-color: #fff;
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); /* Использование clip-path для ромба */
            transform: none; /* Удаление rotate */
        }

        .shape-s_sun {
            background-color: #fff;
            border-radius: 50%;
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 70% 60%, 80% 95%, 50% 70%, 20% 95%, 30% 60%, 2% 35%, 39% 35%);
        }

        .shape-s_cookie {
            background-color: #fff;
            border-radius: 40% 60% 40% 60% / 60% 40% 60% 40%;
        }

        /* V5.2: Color Picker Style */
        /* Объединенные стили для пикеров скина и пули */
        .color-picker-card #customSkinColorPicker, 
        #customColorPicker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: none;
            width: 80px;
            height: 80px;
            padding: 0;
            background: none;
            cursor: pointer;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: inset 0 0 0 4px #2c2e30; 
        }

        #customColorPicker::-webkit-color-swatch-wrapper, 
        #customSkinColorPicker::-webkit-color-swatch-wrapper { padding: 0; }
        #customColorPicker::-webkit-color-swatch, 
        #customSkinColorPicker::-webkit-color-swatch { border: none; }
        #customColorPicker::-moz-color-swatch-wrapper,
        #customSkinColorPicker::-moz-color-swatch-wrapper { padding: 0; }
        #customColorPicker::-moz-color-swatch,
        #customSkinColorPicker::-moz-color-swatch { border: none; }


        /* Controls */
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 80px;
            pointer-events: none; 
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .control-group {
            pointer-events: auto;
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .btn {
            width: 60px; 
            height: 60px; 
            background-color: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 20px; 
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px; 
            user-select: none;
            cursor: pointer;
            color: white;
            font-weight: bold;
        }
        
        .btn:active { background-color: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
        #btnShoot { background-color: rgba(255, 100, 100, 0.3); }
        #btnJump { background-color: rgba(255, 255, 100, 0.3); }
        
        /* UI */
        #uiLayer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 5;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }

        .heart {
            font-size: 30px; 
            margin-right: 5px;
            color: red; 
        }

        /* Chat */
        #chatBox {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 6;
            pointer-events: none;
            max-width: 300px;
            text-align: right;
        }


        /* Game Over Modal */
        #gameOverModal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: #2c2e30;
            padding: 40px;
            border-radius: 28px;
            text-align: center;
            color: white;
        }
    </style>
</head>
<body>

    <div id="menuScreen" class="game-screen">
        <div class="menu-container">
            <button id="langToggle">EN</button> 
            <h1 data-translate="title">BURR GAME V5.3</h1>
            <p style="color:#c4c7c5; font-size: 14px;" data-translate="version_note"></p>

            <h3 data-translate="mode_title"></h3>
            <button class="menu-button btn-primary" onclick="startGame('normal')" data-translate="mode_normal"></button>
            <button class="menu-button btn-warning" onclick="startGame('hardened')" data-translate="mode_hardened"></button>
            <button class="menu-button btn-danger" onclick="startGame('hardcore')" data-translate="mode_hardcore"></button>
            <button class="menu-button btn-info" onclick="startGame('auto')" data-translate="mode_auto"></button>

            <div style="display:flex; gap:10px; margin-top:10px;">
                <button class="menu-button btn-secondary" onclick="openWardrobe()" style="flex:1;" data-translate="skins_btn"></button>
                <button class="menu-button btn-secondary" onclick="openBulletSettings()" style="flex:1;" data-translate="bullets_btn"></button>
            </div>
            
            <p style="margin-top:5px; color:#4CAF50;"><span data-translate="record"></span> <span id="highScore">0</span></p>
        </div>
    </div>

    <div id="wardrobeScreen" class="game-screen" style="display:none;">
        <div class="menu-container">
            <h2 data-translate="skins"></h2>
            <h3 data-translate="color_title"></h3> <div id="skinColorContainer" class="grid-container">
                 <div class="option-card color-picker-card" style="border-radius: 20px;">
                    <input type="color" id="customSkinColorPicker" value="#FF0000" onchange="setCustomSkinColor(this.value)">
                </div>
            </div>
            <h3 data-translate="presets_title"></h3> <div id="skinContainer" class="grid-container"></div>
            <button class="menu-button btn-danger" onclick="showMenu()" data-translate="back"></button>
        </div>
    </div>
    
    <div id="bulletSettingsScreen" class="game-screen" style="display:none;">
        <div class="menu-container">
            <h2 data-translate="bullets"></h2>
            <h3 data-translate="color_title"></h3>
            <div id="bulletColorContainer" class="grid-container">
                <div class="option-card" style="border-radius: 20px;">
                    <input type="color" id="customColorPicker" value="#FFFF00" onchange="setCustomBulletColor(this.value)">
                </div>
            </div>
            <h3 data-translate="shape_title"></h3>
            <div id="bulletShapeContainer" class="grid-container"></div>
            <button class="menu-button btn-danger" onclick="showMenu()" data-translate="back"></button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <button id="autopilotToggle" class="menu-button btn-danger btn-toggle" onclick="disableAutopilotManual()" style="display:none;"></button>
    <div id="uiLayer"></div>
    <div id="chatBox"></div>
    
    <div id="gameOverModal">
        <div class="modal-content">
            <h2 style="color:#F44336" data-translate="game_over"></h2>
            <p id="gameOverText" style="font-size:20px; margin: 20px 0;"><span data-translate="score_label"></span> 0</p>
            <button class="menu-button btn-primary" onclick="location.reload()" data-translate="ok"></button>
        </div>
    </div>

    <div id="controls" style="display:none;">
        <div class="control-group">
            <div class="btn" id="btnLeft">←</div>
            <div class="btn" id="btnRight">→</div>
        </div>
        <div class="control-group">
            <div class="btn" id="btnShoot">⦿</div> <div class="btn" id="btnJump">▲</div>
        </div>
    </div>

    <script>
        // --- 1. ЛОКАЛИЗАЦИЯ (V5.3 UPDATE) ---
        const translations = {
            ru: {
                title: 'BURR GAME V5.3', version_note: '(M3 Style + Colors Update)', mode_title: 'Режим игры:',
                mode_normal: 'START Обычный (V5.0.2)', mode_hardened: 'HARDENED Усложнённый (HP x5)',
                mode_hardcore: 'HARDCORE Хардкор (1 HP)', mode_auto: 'AUTO Автопилот', 
                skins: 'Скины', skins_btn: 'SKINS Скины', presets_title: 'Пресеты цвета:',
                bullets: 'Пули', bullets_btn: 'BULLETS Пули',
                record: 'Рекорд:', back: 'НАЗАД', color_title: 'Цвет:', shape_title: 'Форма:',
                stop_auto: 'СТОП АВТО', player_chat_1: 'Игрок: "Даже не вспотел!"', pusheen_chat_1: 'Pusheen: "я вижу тебя. А ты меня?"',
                pusheen_chat_2: 'Pusheen: "приивееет!!" (мирный)', ai_stop: 'ИИ: Управление передано!',
                ai_stopping: 'ИИ: Ищу безопасное место...', game_over: 'ИГРА ОКОНЧЕНА!', score_label: 'Счет:', ok: 'ОК',
                current_score: 'СЧЕТ:', current_high_score: 'РЕКОРД:', current_mode: 'РЕЖИМ:',
            },
            en: {
                title: 'BURR GAME V5.3', version_note: '(M3 Style + Colors Update)', mode_title: 'Game Mode:',
                mode_normal: 'START Normal (V5.0.2)', mode_hardened: 'HARDENED Hardened (HP x5)',
                mode_hardcore: 'HARDCORE Hardcore (1 HP)', mode_auto: 'AUTO Autopilot', 
                skins: 'Skins', skins_btn: 'SKINS Skins', presets_title: 'Color Presets:',
                bullets: 'Bullets', bullets_btn: 'BULLETS Bullets',
                record: 'High Score:', back: 'BACK', color_title: 'Color:', shape_title: 'Shape:',
                stop_auto: 'STOP AUTO', player_chat_1: 'Player: "Didn\'t even break a sweat!"', pusheen_chat_1: 'Pusheen: "I see you. Do you see me?"',
                pusheen_chat_2: 'Pusheen: "heeeelllooo!!" (peaceful)', ai_stop: 'AI: Controls handed over!',
                ai_stopping: 'AI: Looking for a safe spot...', game_over: 'GAME OVER!', score_label: 'Score:', ok: 'OK',
                current_score: 'SCORE:', current_high_score: 'HIGH SCORE:', current_mode: 'MODE:',
            }
        };

        let currentLang = localStorage.getItem('gameLang') || 'ru';

        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('gameLang', lang);
            const t = translations[lang];

            document.querySelectorAll('[data-translate]').forEach(el => {
                const key = el.getAttribute('data-translate');
                if (t[key]) {
                    el.textContent = t[key];
                }
            });
            
            document.getElementById('highScore').textContent = localStorage.getItem('burr_highScore') || 0;
            document.getElementById('langToggle').textContent = lang === 'ru' ? 'EN' : 'RU';
            
            if (document.getElementById('autopilotToggle') && document.getElementById('autopilotToggle').style.display !== 'none') {
                document.getElementById('autopilotToggle').textContent = t.stop_auto;
            }

            updateHUDText();
        }

        function updateHUDText() {
             const t = translations[currentLang];
             if (!document.getElementById('hudScore')) return; 
             document.getElementById('hudScore').textContent = `${t.current_score} ${score}`;
             document.getElementById('hudRecord').textContent = `${t.current_high_score} ${highScore}`;
             document.getElementById('hudMode').textContent = `${t.current_mode} ${gameMode.type.toUpperCase()}`;
        }


        document.getElementById('langToggle').addEventListener('click', () => {
            const newLang = currentLang === 'ru' ? 'en' : 'ru';
            setLanguage(newLang);
        });
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const uiLayer = document.getElementById('uiLayer');
        uiLayer.innerHTML = `
            <div id="hudScore" style="color:#fff; font-size: 20px;"></div>
            <div id="hudRecord" style="color:#4CAF50; font-size: 20px;"></div>
            <div id="hudMode" style="color:#4fd8eb; font-size: 20px; margin-bottom: 10px;"></div>
            <div id="heartContainer"></div>
        `;
        const heartContainer = document.getElementById('heartContainer');


        // --- ОБНОВЛЕННЫЕ ПРЕСЕТЫ СКИНОВ ---
        const availableSkinPresets = [
            { id: 'cube_red', color: '#FF0000' }, 
            { id: 'cube_grey', color: '#808080' }, 
            { id: 'cube_teal', color: '#008080' }, 
            { id: 'cube_gold', color: '#FFD700' },
            { id: 'cube_white', color: '#FFFFFF' }
        ];

        const availableBulletShapes = [
            { id: 's_rect', name: '■' }, { id: 's_circle', name: '●' }, { id: 's_tri', name: '▲' },
            { id: 's_puffy', name: '' }, { id: 's_diamond', name: '' }, { id: 's_sun', name: '' }, { id: 's_cookie', name: '' }
        ];

        // Изначальный ID скина теперь не важен, важен только цвет
        let currentSkinColor = localStorage.getItem('skinColor') || '#FF0000';
        let currentBulletColor = localStorage.getItem('bulColor') || '#FFFF00';
        let currentBulletShape = localStorage.getItem('bulShape') || 's_rect';

        const assets = { ground: new Image(), bullet: new Image(), spike: new Image() };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        let gameMode = {
            type: 'normal',
            enemyHP: 1, speedMult: 1, isAuto: false, autoState: 'off'
        };

        let gameState = 'MENU';
        const GRAVITY = 0.8; const TERMINAL_VELOCITY = 15; const TILE_SIZE = 50; 
        
        const player = {
            x: 100, y: 100, width: TILE_SIZE, height: TILE_SIZE,
            vx: 0, vy: 0, speed: 7, jumpPower: -16, 
            grounded: false, hp: 3, maxHp: 3,
            facingRight: true, invulnerable: 0, cooldownTimer: 0,
            jumpsLeft: 1, maxJumps: 2
        };

        let bullets = [], enemies = [], targets = [], platforms = [];
        let cameraX = 0, score = 0, lastScoredBlock = 0;
        let highScore = localStorage.getItem('burr_highScore') || 0;
        
        let pusheenSpawned = false, pusheenDefeated = false;
        const pusheenEnemy = { x: -300, y: canvas.height - TILE_SIZE - 50, width: 50, height: 50, hp: 50, type: 'pusheen' };

        const keys = { left: false, right: false, up: false, shoot: false };
        let canShoot = true; 
        const shootCooldown = 15; 

        // --- УПРАВЛЕНИЕ ---
        window.addEventListener('keydown', (e) => {
            if (gameMode.isAuto && gameMode.autoState === 'active') disableAutopilotManual();
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
            if (e.code === 'ArrowUp' || e.code === 'Space' || e.code === 'KeyW') {
                if(gameState === 'MENU' && e.code === 'Space') startGame('normal');
                else keys.up = true;
            }
            if (e.code === 'KeyZ' || e.code === 'KeyE') keys.shoot = true;
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
            if (e.code === 'ArrowUp' || e.code === 'Space' || e.code === 'KeyW') keys.up = false;
            if (e.code === 'KeyZ' || e.code === 'KeyE') keys.shoot = false;
        });

        const addTouch = (id, keyName) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[keyName] = true; if(gameMode.isAuto) disableAutopilotManual(); });
            el.addEventListener('touchend', (e) => { e.preventDefault(); keys[keyName] = false; });
            el.addEventListener('mousedown', (e) => { keys[keyName] = true; });
            el.addEventListener('mouseup', (e) => { keys[keyName] = false; });
        };

        addTouch('btnLeft', 'left'); addTouch('btnRight', 'right');
        addTouch('btnJump', 'up'); addTouch('btnShoot', 'shoot'); 

        // --- МЕНЮ И НАСТРОЙКИ ---
        function showScreen(id) {
            document.querySelectorAll('.game-screen').forEach(s => s.style.display = 'none');
            document.getElementById(id).style.display = 'flex';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('autopilotToggle').style.display = 'none';
            setLanguage(currentLang);
        }

        function showMenu() {
            gameState = 'MENU';
            showScreen('menuScreen');
            document.getElementById('highScore').textContent = localStorage.getItem('burr_highScore') || 0;
        }

        function openWardrobe() { showScreen('wardrobeScreen'); renderSkins(); }
        function openBulletSettings() { 
            showScreen('bulletSettingsScreen'); 
            document.getElementById('customColorPicker').value = currentBulletColor;
            renderBulletSettings(); 
        }
        
        // --- НОВАЯ ФУНКЦИЯ ДЛЯ УСТАНОВКИ ПОЛЬЗОВАТЕЛЬСКОГО ЦВЕТА СКИНА ---
        function setCustomSkinColor(color) {
            currentSkinColor = color; 
            localStorage.setItem('skinColor', color);
            renderSkins(color); // Перерисовываем для обновления выбора
        }


        function renderSkins(selectedColor = currentSkinColor) {
            const cColor = document.getElementById('skinColorContainer');
            const pickerCard = cColor.querySelector('.option-card');
            const picker = document.getElementById('customSkinColorPicker');
            
            // 1. Устанавливаем текущий цвет и выделяем пикер
            picker.value = selectedColor; 
            pickerCard.classList.add('selected'); // Выделяем пикер по умолчанию

            const c = document.getElementById('skinContainer'); c.innerHTML = '';
            
            // 2. Рендерим пресеты
            availableSkinPresets.forEach(s => {
                const d = document.createElement('div'); d.className = 'option-card';
                // Проверяем, совпадает ли текущий цвет с пресетом (для выделения)
                if(selectedColor.toUpperCase() === s.color.toUpperCase()) {
                    d.classList.add('selected');
                    pickerCard.classList.remove('selected'); // Если выбран пресет, снимаем выделение с пикера
                }
                d.innerHTML = `<div class="color-preview" style="background:${s.color}"></div>`;
                d.onclick = () => { 
                    setCustomSkinColor(s.color); // Устанавливаем цвет из пресета
                };
                c.appendChild(d);
            });
            
            // Если выбранный цвет не совпал ни с одним пресетом, выделяем пикер
            let isPresetSelected = availableSkinPresets.some(s => s.color.toUpperCase() === selectedColor.toUpperCase());
            if (!isPresetSelected) {
                pickerCard.classList.add('selected');
            } else {
                pickerCard.classList.remove('selected');
            }
        }


        function setCustomBulletColor(color) {
            currentBulletColor = color; 
            localStorage.setItem('bulColor', color);
            // Если выбран новый цвет, нужно убедиться, что пикер выглядит выбранным
            document.getElementById('bulletColorContainer').querySelector('.option-card').classList.add('selected');
            renderBulletSettings(); 
        }

        function renderBulletSettings() {
            const cColor = document.getElementById('bulletColorContainer'); 
            const pickerCard = cColor.querySelector('.option-card');
            pickerCard.classList.add('selected'); // Пикер всегда выбран, так как это основной способ выбора
            
            const picker = document.getElementById('customColorPicker');
            picker.value = currentBulletColor; 

            const cShape = document.getElementById('bulletShapeContainer'); cShape.innerHTML = '';
            availableBulletShapes.forEach(s => {
                const d = document.createElement('div'); d.className = 'option-card';
                if(currentBulletShape === s.id) d.classList.add('selected');
                
                const preview = document.createElement('div');
                preview.className = `shape-preview shape-${s.id}`;
                preview.textContent = s.name;
                
                if (s.id !== 's_tri') { 
                    preview.style.backgroundColor = '#fff'; 
                }

                d.appendChild(preview);
                
                d.onclick = () => { 
                    currentBulletShape = s.id; 
                    localStorage.setItem('bulShape', s.id); 
                    renderBulletSettings(); 
                };
                cShape.appendChild(d);
            });
        }

        function startGame(mode) {
            gameMode.type = mode;
            gameMode.isAuto = (mode === 'auto');
            gameMode.autoState = (mode === 'auto') ? 'active' : 'off';
            
            if (mode === 'normal' || mode === 'auto') {
                gameMode.enemyHP = 1; gameMode.speedMult = 1; player.maxHp = 3;
            } else if (mode === 'hardened') {
                gameMode.enemyHP = 5; gameMode.speedMult = 1.5; player.maxHp = 3;
            } else if (mode === 'hardcore') {
                gameMode.enemyHP = 5; gameMode.speedMult = 2.0; player.maxHp = 1;
            }

            document.querySelectorAll('.game-screen').forEach(s => s.style.display = 'none');
            document.getElementById('gameCanvas').style.display = 'block';
            
            if (gameMode.isAuto) {
                document.getElementById('autopilotToggle').style.display = 'block';
                document.getElementById('autopilotToggle').textContent = translations[currentLang].stop_auto;
                document.getElementById('controls').style.display = 'none';
            } else {
                document.getElementById('controls').style.display = 'flex';
            }

            gameState = 'PLAYING';
            initLevel();
            loop();
        }

        // --- ИГРОВАЯ ЛОГИКА (ОСТАЛЬНЫЕ ФУНКЦИИ БЕЗ ИЗМЕНЕНИЙ) ---

        function disableAutopilotManual() {
            if(gameMode.autoState === 'active') {
                gameMode.autoState = 'stopping';
                document.getElementById('autopilotToggle').textContent = translations[currentLang].ai_stopping;
                showChat(translations[currentLang].ai_stopping);
            }
        }

        function runAutopilot() {
            if (gameMode.autoState === 'off') return;
            
            if (gameMode.autoState === 'stopping' && player.grounded) {
                gameMode.isAuto = false;
                gameMode.autoState = 'off';
                document.getElementById('autopilotToggle').style.display = 'none';
                document.getElementById('controls').style.display = 'flex';
                keys.right = false; keys.up = false; keys.shoot = false;
                showChat(translations[currentLang].ai_stop);
                return;
            }

            const lookAhead = 150;
            let dangerSpike = false;
            let groundAhead = false;
            let targetAhead = false;

            for (let e of enemies) {
                if (e.x > player.x && e.x < player.x + lookAhead) dangerSpike = true;
            }
            for (let p of platforms) {
                if (p.x < player.x + lookAhead + 50 && p.x + p.width > player.x + lookAhead && Math.abs(p.y - player.y) < TILE_SIZE*2) groundAhead = true;
            }
            for (let t of targets) {
                if (t.x > player.x && t.x < player.x + 400 && Math.abs(t.y - player.y) < 50) targetAhead = true;
            }

            keys.right = true;
            keys.shoot = targetAhead;

            if (dangerSpike || !groundAhead) {
                if (player.grounded) keys.up = true;
                else if (player.jumpsLeft > 0 && player.vy > 0) keys.up = true;
            } else {
                keys.up = false;
            }
        }

        function initLevel() {
            player.hp = player.maxHp;
            player.x = 100; player.y = 100; player.vx = 0; player.vy = 0;
            player.jumpsLeft = player.maxJumps;
            bullets = []; targets = []; enemies = []; platforms = [];
            score = 0; lastScoredBlock = 0;
            pusheenSpawned = false; pusheenDefeated = false;
            
            updateHearts();
            updateHUDText(); 

            for(let i=0; i<5; i++) platforms.push({ x: i * TILE_SIZE, y: canvas.height - TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE });
            platforms.push({ x: -TILE_SIZE, y: canvas.height - TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE }); 

            let currentX = 5 * TILE_SIZE;
            for(let i=0; i<80; i++) {
                const rand = Math.random();
                if (rand < 0.2) { currentX += TILE_SIZE * 2; } 
                else if (rand < 0.8) {
                    let length = Math.floor(Math.random() * 4) + 2; 
                    let platformStartY = canvas.height - TILE_SIZE;
                    for(let j=0; j<length; j++) {
                        platforms.push({ x: currentX, y: platformStartY, width: TILE_SIZE, height: TILE_SIZE });
                        if (j === Math.floor(length/2) && Math.random() < 0.5) {
                            targets.push({ x: currentX, y: platformStartY - TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE, hp: gameMode.enemyHP });
                        }
                        if (j === 0 && length >= 3 && Math.random() < 0.3) {
                            enemies.push({ x: currentX + 10, y: platformStartY - 30, width: 30, height: 30, type: 'spike' });
                        }
                        currentX += TILE_SIZE;
                    }
                    if (length > 3) currentX += TILE_SIZE * 2;
                } else {
                    currentX += TILE_SIZE * 3;
                    let pX = currentX;
                    let pY = canvas.height - TILE_SIZE * (Math.floor(Math.random() * 3) + 3);
                    platforms.push({ x: pX, y: pY, width: TILE_SIZE * 2, height: TILE_SIZE });
                    if (Math.random() < 0.5) enemies.push({ x: pX + 10, y: pY - 30, width: 30, height: 30, type: 'spike' });
                    if (Math.random() < 0.5) targets.push({ x: pX + TILE_SIZE, y: pY - TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE, hp: gameMode.enemyHP });
                    currentX += TILE_SIZE * 2;
                }
                currentX += TILE_SIZE; 
            }
        }

        function checkCollision(r1, r2) {
            return (r1.x < r2.x + r2.width && r1.x + r1.width > r2.x && r1.y < r2.y + r2.height && r1.y + r1.height > r2.y);
        }

        function handleSolidCollision(r1, r2) {
            if (!checkCollision(r1, r2)) return false;
            const dx = (r1.x + r1.width / 2) - (r2.x + r2.width / 2);
            const dy = (r1.y + r1.height / 2) - (r2.y + r2.height / 2);
            const overlapX = (r1.width / 2 + r2.width / 2) - Math.abs(dx);
            const overlapY = (r1.height / 2 + r2.height / 2) - Math.abs(dy);
            
            if (overlapX < overlapY) {
                if (dx > 0) r1.x += overlapX; else r1.x -= overlapX;
                r1.vx = 0;
            } else {
                if (dy > 0) { r1.y += overlapY; r1.vy = 0; } 
                else { r1.y -= overlapY; r1.vy = 0; r1.grounded = true; r1.jumpsLeft = r1.maxJumps; }
            }
            return true;
        }

        function shoot() {
            if (gameState !== 'PLAYING' || !canShoot) return;
            const bSpeed = player.facingRight ? 15 : -15; 
            
            let bulletWidth = 20, bulletHeight = 10;
            // V5.3: Установка размеров пули
            if (currentBulletShape === 's_circle' || currentBulletShape === 's_puffy' || currentBulletShape === 's_diamond' || currentBulletShape === 's_sun' || currentBulletShape === 's_cookie') {
                 bulletWidth = bulletHeight = 20;
            }


            bullets.push({ 
                x: player.x + player.width / 2, y: player.y + player.height / 2 - 5, 
                vx: bSpeed, width: bulletWidth, height: bulletHeight, life: 60, 
                color: currentBulletColor, shape: currentBulletShape 
            });
            canShoot = false;
            player.cooldownTimer = shootCooldown; 
        }

        function update() {
            if (gameState !== 'PLAYING') return;
            if (gameMode.isAuto) runAutopilot();

            if (keys.shoot) shoot();
            if (player.cooldownTimer > 0) player.cooldownTimer--; else if (player.cooldownTimer === 0) canShoot = true;

            let moveSpeed = player.speed * gameMode.speedMult;

            if (keys.left && !gameMode.isAuto) { player.vx = -moveSpeed; player.facingRight = false; } 
            else if (keys.right) { player.vx = moveSpeed; player.facingRight = true; } 
            else { player.vx = 0; }

            if (keys.up) {
                if (player.grounded) { player.vy = player.jumpPower; player.grounded = false; player.jumpsLeft--; } 
                else if (player.jumpsLeft > 0 && !gameMode.isAuto) { player.vy = player.jumpPower; player.jumpsLeft--; keys.up = false; }
                else if (gameMode.isAuto && player.jumpsLeft > 0 && player.vy > 0) { player.vy = player.jumpPower; player.jumpsLeft--; }
            }

            player.vy += GRAVITY;
            if(player.vy > TERMINAL_VELOCITY) player.vy = TERMINAL_VELOCITY;
            player.x += player.vx; player.y += player.vy;

            if (!pusheenSpawned && player.x > 500) { pusheenSpawned = true; enemies.push(pusheenEnemy); showChat(translations[currentLang].pusheen_chat_1); }
            if (pusheenSpawned && !pusheenDefeated && pusheenEnemy.hp <= 0) {
                 pusheenDefeated = true; showChat(translations[currentLang].player_chat_1, 2500); setTimeout(() => showChat(translations[currentLang].pusheen_chat_2), 3000);
            }

            player.grounded = false;
            platforms.forEach(p => handleSolidCollision(player, p));
            targets.forEach(t => handleSolidCollision(player, t));

            if (player.y > canvas.height + 100) takeDamage(3);
            const currentBlock = Math.floor(player.x / TILE_SIZE);
            if (currentBlock > lastScoredBlock + 3) { score += 10; lastScoredBlock = currentBlock; updateHUDText(); }

            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i]; b.x += b.vx; b.life--;
                let hit = false;
                for (let j = targets.length - 1; j >= 0; j--) {
                    let t = targets[j];
                    if (checkCollision(b, t)) { t.hp--; score += 5; hit = true; if (t.hp <= 0) { targets.splice(j, 1); score += 50; } break; }
                }
                if (pusheenSpawned && !pusheenDefeated && checkCollision(b, pusheenEnemy)) { pusheenEnemy.hp--; score += 1; hit = true; }
                if (b.life <= 0 || hit) bullets.splice(i, 1);
            }
            updateHUDText();

            if (player.invulnerable > 0) player.invulnerable--;
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                if (checkCollision(player, e)) {
                    if (e.type === 'spike') { takeDamage(1); break; }
                    else if (e.type === 'pusheen' && !pusheenDefeated) { takeDamage(3); break; }
                }
                if (e.type === 'pusheen' && pusheenDefeated) enemies.splice(i, 1);
            }

            let targetCamX = player.x - canvas.width / 2 + player.width / 2;
            if (targetCamX < 0) targetCamX = 0;
            cameraX += (targetCamX - cameraX) * 0.1; 
        }

        function takeDamage(amount) {
            if (player.invulnerable > 0) return;
            player.hp -= amount; player.invulnerable = 60; player.vy = -5; updateHearts();
            if (player.hp <= 0) {
                gameState = 'GAMEOVER';
                if (score > highScore) { highScore = score; localStorage.setItem('burr_highScore', highScore); }
                
                const t = translations[currentLang];
                document.getElementById('gameOverText').innerHTML = `${t.score_label} ${score} | ${t.record}: ${highScore}`;
                document.getElementById('gameOverModal').style.display = 'flex';
                document.getElementById('controls').style.display = 'none';
                document.getElementById('autopilotToggle').style.display = 'none';
            }
        }

        const chatBox = document.getElementById('chatBox');
        function showChat(message, duration = 2000) {
            chatBox.textContent = message; chatBox.style.opacity = '1';
            setTimeout(() => { chatBox.style.opacity = '0'; }, duration);
        }

        function updateHearts() {
            heartContainer.innerHTML = '';
            for(let i=0; i<player.hp; i++) {
                const h = document.createElement('span'); h.className = 'heart'; h.innerHTML = '♥️'; heartContainer.appendChild(h);
            }
        }

        // --- ОТРИСОВКА (V5.3 FIX) ---
        
        // Вспомогательная функция для отрисовки звезд/лучей
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            let step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.closePath();
            ctx.fill();
        }

        // Вспомогательная функция для отрисовки "мягкого" прямоугольника (Squircle/Cookie)
        function drawRoundedRect(ctx, x, y, w, h, radius) {
            let r = radius; 
            if (r > w / 2) r = w / 2;
            if (r > h / 2) r = h / 2;

            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r); 
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); 
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r); 
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y); 
            ctx.closePath();
            ctx.fill();
        }


        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.translate(-cameraX, 0);

            // ... (Отрисовка платформ, таргетов, врагов - без изменений)
            for (let p of platforms) {
                if (assets.ground.complete && assets.ground.naturalHeight !== 0) ctx.drawImage(assets.ground, p.x, p.y, p.width, p.height);
                else { ctx.fillStyle = '#654321'; ctx.fillRect(p.x, p.y, p.width, p.height); ctx.fillStyle = '#00FF00'; ctx.fillRect(p.x, p.y, p.width, 10); }
            }

            for (let t of targets) {
                ctx.fillStyle = `rgba(0, 0, 255, ${t.hp / gameMode.enemyHP})`; 
                ctx.fillRect(t.x, t.y, t.width, t.height);
                if (assets.ground.complete && assets.ground.naturalHeight !== 0) { ctx.globalAlpha = 0.2; ctx.drawImage(assets.ground, t.x, t.y, t.width, t.height); ctx.globalAlpha = 1.0; }
                ctx.fillStyle = 'white'; ctx.font = 'bold 20px monospace'; ctx.fillText(t.hp, t.x + t.width/2 - 5, t.y + t.height/2 + 5);
            }

            for (let e of enemies) {
                if(e.type === 'spike') {
                    if (assets.spike.complete && assets.spike.naturalHeight !== 0) ctx.drawImage(assets.spike, e.x, e.y, e.width, e.height);
                    else { ctx.fillStyle = 'purple'; ctx.beginPath(); ctx.moveTo(e.x, e.y+e.height); ctx.lineTo(e.x+e.width/2, e.y); ctx.lineTo(e.x+e.width, e.y+e.height); ctx.fill(); }
                } else if (e.type === 'pusheen') {
                    if (!pusheenDefeated) {
                        ctx.fillStyle = 'darkred'; ctx.fillRect(e.x, e.y, e.width, e.height);
                        ctx.fillStyle = 'white'; ctx.font = '16px monospace'; ctx.fillText(`BOSS`, e.x, e.y-5);
                    } else {
                        ctx.fillStyle = 'pink'; ctx.fillRect(e.x, e.y, e.width, e.height);
                        ctx.fillStyle = 'black'; ctx.font = '16px monospace'; ctx.fillText(`PUSHEEN`, e.x, e.y-5);
                    }
                }
            }

            for (let b of bullets) {
                ctx.fillStyle = b.color;
                
                // V5.3: Исправленная отрисовка фигур
                if (b.shape === 's_circle') { 
                    ctx.beginPath(); 
                    ctx.arc(b.x + b.width/2, b.y + b.height/2, b.width/2, 0, Math.PI * 2); 
                    ctx.fill(); 
                } else if (b.shape === 's_tri') {
                    ctx.beginPath();
                    if(b.vx > 0) { ctx.moveTo(b.x, b.y); ctx.lineTo(b.x + b.width, b.y + b.height / 2); ctx.lineTo(b.x, b.y + b.height); }
                    else { ctx.moveTo(b.x + b.width, b.y); ctx.lineTo(b.x, b.y + b.height / 2); ctx.lineTo(b.x + b.width, b.y + b.height); }
                    ctx.fill();
                } else if (b.shape === 's_diamond') {
                    // Точная отрисовка ромба
                    let cx = b.x + b.width / 2;
                    let cy = b.y + b.height / 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, b.y); // Top
                    ctx.lineTo(b.x + b.width, cy); // Right
                    ctx.lineTo(cx, b.y + b.height); // Bottom
                    ctx.lineTo(b.x, cy); // Left
                    ctx.closePath();
                    ctx.fill();
                } else if (b.shape === 's_sun') {
                    // Отрисовка звезды
                    drawStar(ctx, b.x + b.width/2, b.y + b.height/2, 5, b.width/2, b.width/4);
                } else if (b.shape === 's_cookie' || b.shape === 's_puffy') {
                    // Отрисовка сквиркла/печенья
                    drawRoundedRect(ctx, b.x, b.y, b.width, b.height, b.width * 0.4); 
                } else { 
                    ctx.fillRect(b.x, b.y, b.width, b.height); 
                }
            }
            
            // --- ГЛАВНОЕ ИЗМЕНЕНИЕ: ИСПОЛЬЗУЕМ currentSkinColor ДЛЯ ОТРИСОВКИ ПЛЕЕРА ---
            if (player.invulnerable % 10 < 5) { ctx.fillStyle = currentSkinColor; ctx.fillRect(player.x, player.y, player.width, player.height); }

            if (!player.grounded && player.jumpsLeft > 0) {
                const bx = player.x + 10; const by = player.y - 15;
                ctx.fillStyle = 'rgba(255,0,0,0.5)'; ctx.fillRect(bx, by, 30, 5);
                if(player.jumpsLeft === 1) { ctx.fillStyle = '#00FF00'; ctx.fillRect(bx, by, 15, 5); }
            }

            ctx.restore();
            ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.font = 'bold 16px monospace';
            ctx.fillText('V5.3+', canvas.width - 60, 20); // Немного меняем версию для отличия
        }

        function loop() {
            update(); draw();
            if (gameState === 'PLAYING') requestAnimationFrame(loop);
        }
        
        window.onload = function() { 
            setLanguage(currentLang);
            showMenu(); 
        };
    </script>
</body>
</html>
